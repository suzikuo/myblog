---
title: mysql 执行流程知识汇总
tags: 
- mysql
categories:
- mysql
date: 2024-01-29 16:16:50
---

- [一、MySql](#一mysql)
  - [1.1 Server层](#11-server层)
    - [1.1.1 连接器](#111-连接器)
    - [1.1.2 查询缓存](#112-查询缓存)
    - [1.1.3 解析SQL](#113-解析sql)
      - [1.1.3.1 解析器](#1131-解析器)
    - [1.1.4 执行SQL](#114-执行sql)
      - [1.1.4.1 预处理器](#1141-预处理器)
      - [1.1.4.2 优化器](#1142-优化器)
      - [1.1.4.3 执行器](#1143-执行器)
  - [1.2 存储引擎层](#12-存储引擎层)
  - [1.3 参考](#13-参考)

# 一、MySql

## 1.1 Server层
![](https://img-blog.csdnimg.cn/direct/be072fe627684cd48eed569254957cc4.png)
### 1.1.1 连接器

> 连接的过程需要先经过 TCP 三次握手，因为 MySQL 是基于 TCP 协议进行传输的。

 - 管理客户端连接。
 - 权限验证。



```bash
MySQL 的连接也跟 HTTP 一样，有**短连接**和**长连接**的概念，它们的区别如下： 
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）
// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```

### 1.1.2 查询缓存

 

>  如果是查询语句，先去缓存中查询，若有则直接返回给客户端。若没有，在查询后存储到缓存。

 - **当有更新、删除操作时，缓存会被清除。** 对于更新比较频繁的表，查询缓存的命中率很低。
 - MySQL 8.0 版本已删除查询缓存。	（**注意：和InnoDB的缓冲池 buffer pool不一样**）
 - 对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。
### 1.1.3 解析SQL
#### 1.1.3.1 解析器

> 在正式执行 SQL 查询语句之前， MySQL 会先对 SQL 语句做解析，也就是在解析器中解析sql。

 1. 词法分析。提取关键字和非关键字，例如**select**、**from**。
 2. 语法分析。解析sql语句格式是否正确，例如将**from写成form**会报错。**在此过程不会分析字段和表是否存在。**

### 1.1.4 执行SQL
#### 1.1.4.1 预处理器

 - 检查 SQL 查询语句中的表或者字段是否存在；
 - 将 select * 中的 * 符号，扩展为表上的所有列；

#### 1.1.4.2 优化器

> 经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。
> 基于查询成本的考虑， 选择查询成本最小的执行计划；

**优化器主要负责将 SQL 查询语句的执行方案确定下来。** 比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。
可以通过在查询语句之前添加**explain** 来查看会用到哪些索引。

#### 1.1.4.3 执行器

> 经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。
> 在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的

 1. 存储引擎每查出一条数据将结果返回给执行器，由执行器判断是否完全符合条件。
 2. 不符合继续向存储引擎索要下一条记录，如此往复，直到存储引擎把表中的所有记录读完。
 3. 如果符合，执行器会返回给客户端。（Server层每从存储引擎读到一条记录就会发送给客户端，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）

## 1.2 存储引擎层
![](https://img-blog.csdnimg.cn/direct/2da9abbcec0344e0940bf9d79a3d6289.png)

 1. 0、数据更新时执行器先找buffer pool缓存池中，如果在缓冲池中，同时返回给执行器。
 2. 1、如果未命中缓存，需要先从磁盘读入内存，然后再返回给执行器。
 3. 2、不管是否命中缓存，都需要将更新前的旧数据写入到undo中。
 4. 3、更新内存，此时变成脏数据，后续会调用接口将数据落盘。
 5. 4、5、同时将这个更新操作记录到redo log里面，此时redo log处于 prepare
    状态。然后告知执行器执行完成了，随时可以提交事务。
 6. 6、7、执行器生成这个操作的binlog，并把binlog写入磁盘。
 7. 8、执行器调用引擎的提交事务接口，引擎把刚刚写入的redo log改成提交(commit)状态，更新完成。

## 1.3 参考

 - **[图解MySQL是如何运行的](https://mp.weixin.qq.com/s?__biz=MzI2NzM1OTM4OA==&mid=2247496095&idx=1&sn=f778531f1b45658bffa06b7dfda3c53b&chksm=ea82b46cddf53d7aaee7e0fb278bb833df60b47d062add6fceae25565506e6c2b56ad7bfdb0f&scene=126&&sessionid=0)**
 - **[执行一条 select 语句，期间发生了什么？](https://www.xiaolincoding.com/mysql/base/how_select.html#mysql-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84)**

