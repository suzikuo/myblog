---
title: TCP三次握手与四次挥手知识汇总
tags: 
- tcp
categories:
- tcp
date: 2024-01-18 18:16:54
---

- [一、TCP](#一tcp)
  - [1.1 总览图](#11-总览图)
  - [1.2 什么是SYN、ACK、FIN、ack、seq？](#12-什么是synackfinackseq)
  - [1.3三次握手](#13三次握手)
    - [1.3.1 总览图](#131-总览图)
    - [1.3.2 什么是三次握手](#132-什么是三次握手)
    - [1.3.3 为什么需要三次握手？](#133-为什么需要三次握手)
    - [1.3.4 两次握手会如何？](#134-两次握手会如何)
    - [1.3.5 客户端发送SYN后，服务端为什么还要返回SYN?](#135-客户端发送syn后服务端为什么还要返回syn)
    - [1.3.6 服务端返回SYN后，为什么还要返回ACK?](#136-服务端返回syn后为什么还要返回ack)
    - [1.3.7 为什么三次握手的时候ack=seq+1?](#137-为什么三次握手的时候ackseq1)
  - [1.4四次挥手](#14四次挥手)
    - [1.4.1 总览图](#141-总览图)
    - [1.4.2 什么是四次挥手？](#142-什么是四次挥手)
    - [1.4.3 为什么需要四次挥手？](#143-为什么需要四次挥手)
    - [1.4.4 为什么要等待2MSL的时间才close？](#144-为什么要等待2msl的时间才close)
  - [1.5 如果握手(挥手)期间出现故障怎么办？](#15-如果握手挥手期间出现故障怎么办)
  - [参考](#参考)


> 这篇文档写的很详细：[https://www.xiaolincoding.com/network/3_tcp/tcp_feature.html#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6](https://www.xiaolincoding.com/network/3_tcp/tcp_feature.html#%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6)

## 一、TCP
### 1.1 总览图
TCP报文数据格式：
![](https://img-blog.csdnimg.cn/direct/49145a01dd3f40a08949c36f59b6b9ed.png)
**TCP报文首部**

 - 源端口和目的端口，各占2个字节，分别写入源端口和目的端口；
 - 序号，占4个字节，TCP连接中传送的字节流中的每个字节都按顺序编号。例如，一段报文的序号字段值是 301
   ，而携带的数据共有100字段，显然下一个报文段（如果还有的话）的数据序号应该从401开始；
 - 确认号，占4个字节，是期望收到对方下一个报文的第一个数据字节的序号。例如，B收到了A发送过来的报文，其序列号字段是501，而数据长度是200字节，这表明B正确的收到了A发送的到序号700为止的数据。因此，B期望收到A的下一个数据序号是701，于是B在发送给A的确认报文段中把确认号置为701；
 - 数据偏移，占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远；
 - 保留，占6位，保留今后使用，但目前应都位0；
 - 紧急URG，当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据；
 - 确认ACK，仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1；
 - 推送PSH，当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1；
 - 复位RST，当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接；
 - 同步SYN，在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1；
 - 终止FIN，用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放；
 - 窗口，占2字节，指的是通知接收方，发送本报文你需要有多大的空间来接受；
 - 检验和，占2字节，校验首部和数据这两部分；
 - 紧急指针，占2字节，指出本报文段中的紧急数据的字节数；
 - 选项，长度可变，定义一些其他的可选的参数。

### 1.2 什么是SYN、ACK、FIN、ack、seq？
这里只介绍SYN、ACK、FIN这三个标志位。一共有六个。

 - **SYN**:代表请求创建连接。所以在三次握手中前两次要SYN=1，表示这两次用于建立连接。
 - **FIN**：代表请求关闭连接。在四次分手时，我们发现FIN客户端与服务端各发了一次。这是因为TCP的连接是双向的，所以**一次FIN只能关闭一个方向**。
 - **ACK**：代表确认接受。不管是三次握手还是四次分手，在回应的时候都会加上ACK=1，表示消息接收到了，并且在建立连接以后的发送数据时，都需加上ACK=1,来表示数据接收成功。
 - **seq**:序列号。当发送一个数据时，数据是被拆成多个数据包来发送，序列号就是对每个数据包进行编号，这样接受方才能对数据包进行再次拼接。
 初始序列号是随机生成的，这样不一样的数据拆包解包就不会连接错了。
 - **ack**:这个代表下一个数据包的编号，这也就是为什么第二请求时，ack是seq+1。
 **注意：ACK与ack含义不一样。**

### 1.3三次握手
#### 1.3.1 总览图
![](https://img-blog.csdnimg.cn/direct/d7892d0650b843a8b812c093bdcef612.png)

#### 1.3.2 什么是三次握手

> 所谓三次握手（Three-Way Handshake）即**建立TCP连接**，就是指建立一个TCP连接时，需要客户端和服务端总共发送**3个包**以确认连接的建立。**三次握手必须是客户端发起。**

#### 1.3.3 为什么需要三次握手？

> 三次握手的目的是**建立可靠的通信信道**，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。
#### 1.3.4 两次握手会如何？
如果发送两次就可以建立连接话，那么只要客户端发送一个连接请求，服务端接收到并发送了确认，就会建立一个连接。
**那么可能会出现以下问题：**
如果一个连接请求在网络中跑的慢，超时了，这时客户端会重新发起请求，但是这个跑的慢的请求最后还是跑到了，然后服务端就接收了两个连接请求，然后全部回应就会创建两个连接，浪费资源！ 
如果加了第三次客户端确认，客户端在接受到一个服务端连接确认请求后，后面再接收到的连接确认请求就可以抛弃不管了。

#### 1.3.5 客户端发送SYN后，服务端为什么还要返回SYN?

> 接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。
#### 1.3.6 服务端返回SYN后，为什么还要返回ACK?
> 双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。
#### 1.3.7 为什么三次握手的时候ack=seq+1?
> 
> seq是要发送的第一个字节的序号，ack等于他收到的seq序列号加上字节流数据的长度，他代表期望收到的下一个字节的序号，同时他也代表这个序号前的字节我都已经收到了。

[为什么三次握手的时候ack=seq+1](https://blog.csdn.net/oldfish_C/article/details/105150516)

ack = seq + 数据长度(SYN、FIN 长度为1bit)
### 1.4四次挥手
#### 1.4.1 总览图
![](https://img-blog.csdnimg.cn/direct/dcf484ef8b9449289f5c0a515e694a8c.png)


#### 1.4.2 什么是四次挥手？

> 所谓“四次挥手”就是**关闭TCP连接**的过程，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认**双方连接**的断开。

#### 1.4.3 为什么需要四次挥手？

> **TCP是双向的**，所以需要在两个方向分别关闭，每个方向的关闭又需要请求和确认，所以一共就4次。
> 服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，**也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接**，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。

#### 1.4.4 为什么要等待2MSL的时间才close？

 - *为了保证客户端发送的最后一个ACK报文段能够到达服务器*。因为这个ACK有可能丢失，从而导致处在LAST-ACK状态的服务器收不到对FIN-ACK的确认报文。服务器会超时重传这个FIN-ACK，接着客户端再重传一次确认，重新启动时间等待计时器。最后客户端和服务器都能正常的关闭。假设客户端不等待2MSL，而是在发送完ACK之后直接释放关闭，一但这个ACK丢失的话，服务器就无法正常的进入关闭连接状态。
 - *等待最⼤的2msl可以让本次连接的所有的⽹络包在链路上消失，以防造成不必要的⼲扰。* 他还可以防止已失效的报文段。客户端在发送最后一个ACK之后，再经过经过2MSL，就可以使本链接持续时间内所产生的所有报文段都从网络中消失。从保证在关闭连接后不会有还在网络中滞留的报文段去骚扰服务器。

### 1.5 如果握手(挥手)期间出现故障怎么办？
[TCP三次握手及四次挥手过程中的异常处理](https://zhuanlan.zhihu.com/p/641988031)

### 参考

 - [两张动图-彻底明白TCP的三次握手与四次挥手](https://blog.csdn.net/qzcsu/article/details/72861891)
 - [对TCP三次握手四次分手还不清楚，超简单解析](https://baijiahao.baidu.com/s?id=1593714120815701015&wfr=spider&for=pc)

